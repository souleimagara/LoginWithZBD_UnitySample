using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Newtonsoft.Json;
using static Data;

namespace Beamable.Microservices
{
	[Microservice("LoginServer")]
	public class LoginServer : Microservice
	{



        [ClientCallable]
        public async Task<string> GenerateOauthUrl()
        {
            // Generate the PKCE
            string[] pkce = GeneratePKCE();
            string verifier = pkce[0];
            string challenge = pkce[1];

            // State is used to track users on callback, just use a random string for now, but ideally, this would be a user ID or unique user reference
            string state = Guid.NewGuid().ToString();
            var oauthData = new OauthData();
            // Save to config beamable as OS may close the app during redirect, so the app could be reopened with the deep link URI data hence we need to be able to get the last verifier and/or state
            // Save to config beamable as OS may close the app during redirect, so the app could be reopened with the deep link URI data hence we need to be able to get the last verifier and/or state
            bool isVerifierSet = await SetStats("verifier", verifier);
            bool isStateSet = await SetStats("state", state);

            if (!isVerifierSet || !isStateSet)
            {
                oauthData.ErrorMessage = "Failed to save verifier or state to Beamable stats.";
                return JsonConvert.SerializeObject(oauthData);
            }
            RealmConfig config = await Services.RealmConfig.GetRealmConfigSettings();
            string redirectUrl = config.GetSetting("accounts", "redirectUrl", "");
            string clientId = config.GetSetting("accounts", "clientId", "");
            BeamableLogger.Log("the redirectUrl is  " + redirectUrl);
            BeamableLogger.Log("the clientId is  " + clientId);

        

            // Generate the oauth URL and open in webview or browser
            if (string.IsNullOrEmpty(clientId) ||  string.IsNullOrEmpty(redirectUrl))
            {
                oauthData.ErrorMessage = "Missing client id or redirect url. Please check them again or retry later!";
            }
            else
            {
                string zbdOauthUrl = "https://api.zebedee.io/v1/oauth2/authorize?redirect_uri=";
                using (HttpClient client = new HttpClient())
                {
                    string escapedRedirectUrl = Uri.EscapeDataString(redirectUrl);
                    zbdOauthUrl += escapedRedirectUrl;
                    zbdOauthUrl += "&scope=user&client_id=" + clientId;
                    zbdOauthUrl += "&response_type=code&code_challenge=" + challenge + "&code_challenge_method=S256&state=" + state;


                }
                oauthData.Url = zbdOauthUrl;
                BeamableLogger.Log("the final result of Url is  " + zbdOauthUrl);
            }

            return JsonConvert.SerializeObject(oauthData);
        }
        
        
       [ClientCallable]
public async Task<string> ContinueLogin(string url, long beamableid)
{
    var result = new LoginResult();
    string redirectUrl = "";
    string clientId = "";
    string clientsecret = "";
    string verif = ""; 
    string responseContent = ""; 
    try
    {
        RealmConfig config = await Services.RealmConfig.GetRealmConfigSettings();
        redirectUrl = config.GetSetting("accounts", "redirectUrl", "");
        clientId = config.GetSetting("accounts", "clientId", "");
        clientsecret = config.GetSetting("accounts", "clientSecret", "");
        BeamableLogger.Log("The redirectUrl is " + redirectUrl + " " + url);

        if (!url.Contains(redirectUrl))
        {
            result.ErrorMessage += "URL does not contain the expected redirect URL.";
            return JsonConvert.SerializeObject(result);
        }

        BeamableLogger.Log("cont login " + url);
        string code = getParam(url, "code");
        string state = getParam(url, "state");
        var (isSuccess, verifier) = await GetStats(beamableid, "verifier");

        if (isSuccess && verifier != null)
        {
            var accessTokenResult = await GetOauthAccessToken(code, verifier, state, clientId, clientsecret, redirectUrl);
    
            if (accessTokenResult.isSuccess)
            {
                result.AccessToken = accessTokenResult.AccessToken;
                result.RefreshToken = accessTokenResult.RefreshToken;
                result.ExpiresIn = accessTokenResult.ExpiresIn;
                result.RefreshTokenExpiresIn = accessTokenResult.RefreshTokenExpiresIn;
                await SaveTokenDetails(accessTokenResult.AccessToken, accessTokenResult.RefreshToken, accessTokenResult.ExpiresIn , accessTokenResult.RefreshTokenExpiresIn);
                try
                {
                    result.UserData = JsonConvert.DeserializeObject<UserDataResponse>(accessTokenResult.UserData);
                }
                catch (JsonException ex)
                {
                    result.ErrorMessage = "Failed to deserialize user data: " + ex.Message;
                    return JsonConvert.SerializeObject(result);
                }
            }
            else
            {
                result.ErrorMessage += "Failed to retrieve access token.";
            }
        }
        return JsonConvert.SerializeObject(result);
    }
    catch (Exception ex)
    {
        BeamableLogger.LogError("An error occurred in ContinueLogin test : " + ex.Message);
        return JsonConvert.SerializeObject(result.ErrorMessage += " An unexpected error occurred." + " redirectUrl : " +redirectUrl+ " clientId : " +clientId+ " clientsecret : " +clientsecret + " result.AccessToken  " + result.AccessToken + " the verifier " +verif +" responseContent : " + responseContent);
    }
}

  
[ClientCallable]
private async Task<string> GetplayerStats(long userid)
{
    try
    {
        // Retrieve the player's country code asynchronously
        string[] statslist = new string[] { "AccessToken" , "RefreshToken" , "RefreshTokenExpiry" , "AccessTokenExpiry"};
        Dictionary<string, string> stats = await Services.Stats.GetStats("client", "private", "player", 1753365556098049, statslist);
        BeamableLogger.Log("the stats is: " +stats.Values);
        TokenStats playerStats = new TokenStats
        {
            AccessToken = stats["AccessToken"],
            RefreshToken = stats["RefreshToken"],
            AccessTokenExpiry = long.Parse(stats["AccessTokenExpiry"]),
            RefreshTokenExpiry = long.Parse(stats["RefreshTokenExpiry"])
         
        };         
        string serializedStats = JsonConvert.SerializeObject(playerStats);
           
        return serializedStats;
   
    }
    catch (Exception ex)
    {
        // Handle exceptions if necessary
        // For example, log the error or return a default value
        BeamableLogger.LogError("Error retrieving player's country code: " + ex.Message);
        return null;
    }
}
[ClientCallable]
public async Task<string> CheckTokenStatus(long userId ,  bool isTesting  )
{
    // Retrieve token details from Beamable stats
    string[] tokenFields = new string[] { "AccessToken", "RefreshToken", "AccessTokenExpiry", "RefreshTokenExpiry" };
    Dictionary<string, string> tokenDetails = await Services.Stats.GetStats("client", "private", "player", userId, tokenFields);

    BeamableLogger.Log("Token details fetched: " + JsonConvert.SerializeObject(tokenDetails));
    // Initialize the response object
    LoginResult result = new LoginResult();
    // Check if all required token details are available
    if (tokenDetails.Count < tokenFields.Length)
    {
        return JsonConvert.SerializeObject(new
        {
            IsLoggedIn = false,
            ErrorMessage = "Token details are incomplete or missing. Retrieved: " + tokenDetails.Count + ". Please try again in a few minutes or login again."
        });
    }

    TokenStats tokens = new TokenStats
    {
        AccessToken = tokenDetails["AccessToken"],
        RefreshToken = tokenDetails["RefreshToken"],
        AccessTokenExpiry = long.Parse(tokenDetails["AccessTokenExpiry"]),
        RefreshTokenExpiry = long.Parse(tokenDetails["RefreshTokenExpiry"])
    };

    long currentUnixTimeSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
    // If in testing mode, adjust the current time by testTimeOffset seconds
    if (isTesting)
    { 
        int testTimeOffset = (int)( tokens.AccessTokenExpiry - currentUnixTimeSeconds + 90000);
        currentUnixTimeSeconds += testTimeOffset;
    }
    // Check the validity of the access token
    if (currentUnixTimeSeconds < tokens.AccessTokenExpiry)
    {
        result.IsLoggedIn = true;
        result.AccessToken = tokens.AccessToken;
        result.RefreshToken = tokens.RefreshToken;
        result.ExpiresIn = (int)(tokens.AccessTokenExpiry - currentUnixTimeSeconds);
        result.RefreshTokenExpiresIn = (int)(tokens.RefreshTokenExpiry - currentUnixTimeSeconds);
        // Optionally fetch user data using the valid access token
        var userDataResponse = await GetUserData(tokens.AccessToken);
        if (userDataResponse.isSuccess)
        {
            result.UserData = JsonConvert.DeserializeObject<UserDataResponse>(userDataResponse.UserData);
        }
        else
        {
            result.ErrorMessage = "error is " +userDataResponse.UserData +  " Failed to fetch user data.";
        }
    }
    else if (currentUnixTimeSeconds < tokens.RefreshTokenExpiry)
    {
        
        // The access token is expired but the refresh token is still valid
        var refreshResult = await RefreshAccessToken(tokens.RefreshToken);
        if (!string.IsNullOrEmpty(refreshResult.ErrorMessage))
        {
            return JsonConvert.SerializeObject(refreshResult);
        }
        // With the new access token, now fetch user data
        var userDataResponse = await GetUserData(refreshResult.AccessToken);
        if (userDataResponse.isSuccess)
        {
            refreshResult.UserData = JsonConvert.DeserializeObject<UserDataResponse>(userDataResponse.UserData);
            return JsonConvert.SerializeObject(refreshResult);
        }
        else
        {
            return JsonConvert.SerializeObject(new { IsLoggedIn = false, ErrorMessage = "Failed to fetch user data with the refreshed access token." });
        }

      /*  result.NeedsRefresh = true;
        result.RefreshToken = tokens.RefreshToken;
        result.RefreshTokenExpiresIn = (int)(tokens.RefreshTokenExpiry - currentUnixTimeSeconds);
        result.ErrorMessage = "The access token is expired but the refresh token is still valid";*/
    }
    else
    {
        // Both tokens are expired
        return JsonConvert.SerializeObject(new { IsLoggedIn = false, ErrorMessage = "Both tokens expired. Please log in again." });
    }
    
    return JsonConvert.SerializeObject(result);
}



private async Task<LoginResult> RefreshAccessToken(string refreshToken)
{
    var config = await Services.RealmConfig.GetRealmConfigSettings();
    var clientId = config.GetSetting("accounts", "clientId", "");
    var clientSecret = config.GetSetting("accounts", "clientSecret", "");  // Ensure this is securely handled
    var redirectUri = config.GetSetting("accounts", "redirectUrl", "");

    using (var client = new HttpClient())
    {
        var requestData = new Dictionary<string, string>
        {
            {"grant_type", "refresh_token"},
            {"refresh_token", refreshToken},
            {"client_id", clientId},
            {"client_secret", clientSecret},  // This should be securely stored and used
            {"redirect_uri", redirectUri}
        };

        var content = new FormUrlEncodedContent(requestData);
        var response = await client.PostAsync("https://api.zebedee.io/v1/oauth2/token", content);
        if (response.IsSuccessStatusCode)
        {
            var responseString = await response.Content.ReadAsStringAsync();
            var data = JsonConvert.DeserializeObject<dynamic>(responseString);

            // Save the new tokens
            await SaveTokenDetails(data.access_token, data.refresh_token, data.expires_in, data.refresh_token_expires_in);

            return new LoginResult
            {
                IsLoggedIn = true,
                AccessToken = data.access_token,
                RefreshToken = data.refresh_token,
                ExpiresIn = data.expires_in,
                RefreshTokenExpiresIn = data.refresh_token_expires_in
            };
        }
        else
        {
            return new LoginResult { ErrorMessage = "Failed to refresh access token." };
        }
    }
}

private async Task<(bool isSuccess, string AccessToken, string RefreshToken, int ExpiresIn, int RefreshTokenExpiresIn, string UserData)> GetOauthAccessToken(string code, string verifier, string state, string clientId, string clientSecret, string redirectUrl)
{
    using (HttpClient client = new HttpClient())
    {
        var requestData = new
        {
            code = code,
            client_id = clientId,
            client_secret = clientSecret, // THIS SHOULD BE ON THE SERVER!
            code_verifier = verifier,
            grant_type = "authorization_code",
            redirect_uri = redirectUrl
        };

        string jsonString = JsonConvert.SerializeObject(requestData);
        var content = new StringContent(jsonString, System.Text.Encoding.UTF8, "application/json");
        var response = await client.PostAsync("https://api.zebedee.io/v1/oauth2/token", content);
        var responseContent = await response.Content.ReadAsStringAsync();

        if (response.IsSuccessStatusCode)
        {
            var data = JsonConvert.DeserializeObject<dynamic>(responseContent);
            string accessToken = data.access_token;
            string refreshToken = data.refresh_token;
            int expiresIn = data.expires_in;
            int refreshTokenExpiresIn = data.refresh_token_expires_in;
            var (isUserDataSuccess, userData) = await GetUserData(accessToken);
            return (true, accessToken, refreshToken, expiresIn, refreshTokenExpiresIn, userData);
        }
        else
        {
            BeamableLogger.LogError("Failed to get access token: " + responseContent);
            return (false, null, null, 0, 0, null);
        }
    }
}

        private async Task<(bool isSuccess, string UserData)> GetUserData(string accessToken)
        {
            RealmConfig config = await Services.RealmConfig.GetRealmConfigSettings();
            string apikey  = config.GetSetting("accounts", "apikey", "");
            BeamableLogger.Log("The apikey is " + apikey );
            using (HttpClient client = new HttpClient())
            {
                client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);
                // Optional: Add additional headers if needed
                client.DefaultRequestHeaders.Add("apikey", apikey);
               
                var response = await client.GetAsync("https://api.zebedee.io/v1/oauth2/user");
                var responseContent = await response.Content.ReadAsStringAsync();

                if (response.IsSuccessStatusCode)
                {
                    try
                    {
                        var data = JsonConvert.DeserializeObject<dynamic>(responseContent);

                        if (data.error == true)
                        {
                            string message = data.message != null ? data.message.Value : "Unknown error";
                            string detailedData = data.data != null ? data.data.Value : "";
                            
                            BeamableLogger.LogError("User data retrieval error: " + message);
                            return (false, $"Error: {message}, Data: {detailedData}");
                        }
                        else
                        {
                            return (true, responseContent);
                        }
                    }
                    catch (Exception ex)
                    {
                        BeamableLogger.LogError("Failed to parse user data: " + ex.Message);
                        return (false, "Failed to parse user data");
                    }
                }
                else
                {
                    BeamableLogger.LogError("Failed to get user data: " + responseContent);
                    return (false, responseContent);
                }
            }
        }
        
       
        private async Task<bool> SetStats(string key, string value)
        {
            if (value != null ||  key != null)
            {
                try
                {
                    string access = "private";
                    Dictionary<string, string> setStats = new Dictionary<string, string>() { { key, value } };
                    await Services.Stats.SetStats(access, setStats);
                    return true;
                }
                catch (Exception ex)
                {
                    BeamableLogger.LogError("Error setting stats: " + ex.Message);
                    return false;
                }
            }
            return false;
        }
        
        public async Task<(bool isSuccess, string value)> GetStats(long beamableid, string key)
        {
            try
            {
                string[] deviceNames = new string[] { key };
                Dictionary<string, string> stats = await Services.Stats.GetStats("client", "private", "player", beamableid, deviceNames);
        
                if (stats.ContainsKey(key))
                {
                    return (true, stats[key]);
                }
                else
                {
                    return (false, null);
                }
            }
            catch (Exception ex)
            {
                BeamableLogger.LogError("Error retrieving stats: " + ex.Message);
                return (false, null);
            }
        }
        
        [ClientCallable]
        public async Task<string> Logout(long userId)
        {
            try
            {
                // Clear the stored tokens
                string[] keys = { "AccessToken", "RefreshToken", "AccessTokenExpiry", "RefreshTokenExpiry" };
                await Services.Stats.DeleteStats("client", "private", "player", userId, keys);
              
                BeamableLogger.Log("User logged out successfully.");
                return JsonConvert.SerializeObject(new { Success = true, Message = "Logout successful." });
            }
            catch (Exception ex)
            {
                BeamableLogger.LogError("An error occurred during logout: " + ex.Message);
                return JsonConvert.SerializeObject(new { Success = false, Message = "Logout failed. Please try again." });
            }
        }

        
        private async  Task<bool> SaveTokenDetails(string accessToken, string refreshToken, int expiresIn, int refreshTokenExpiresIn)
        {
            try
            {
            long currentUnixTimeSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
            long accessTokenExpiry = currentUnixTimeSeconds + expiresIn;
            long refreshTokenExpiry = currentUnixTimeSeconds + refreshTokenExpiresIn;
            string access = "private";
            var tokenDetails = new Dictionary<string, string>
            {
                {"AccessToken", accessToken},
                {"RefreshToken", refreshToken},
                {"AccessTokenExpiry", accessTokenExpiry.ToString()},
                {"RefreshTokenExpiry", refreshTokenExpiry.ToString()}
            };
            await Services.Stats.SetStats(access, tokenDetails);
            return true; // Assume success if no exceptions are thrown
            
            }
            catch (Exception ex)
            {
                // Log the exception or handle it as needed
                BeamableLogger.LogError("Failed to save token details: " + ex.Message);
                return false; // Return false indicating that saving the token details failed
            }
        }
        
        
        
     private  string[] GeneratePKCE()
        {

            byte[] randomBytes = new byte[32];
            System.Random random = new System.Random();
            random.NextBytes(randomBytes);

            // encode
            string verifier = URLEncode(Convert.ToBase64String(randomBytes));

            // hash and encode to get the challenge
            byte[] sha256 = Sha256(verifier);
            string challenge = URLEncode(Convert.ToBase64String(sha256));
            return new string[2] { verifier, challenge };


        }

        public static byte[] Sha256(string s)
        {
            // Form hash
            System.Security.Cryptography.SHA256 h = System.Security.Cryptography.SHA256.Create();
            byte[] data = h.ComputeHash(System.Text.Encoding.Default.GetBytes(s));
            return data;
        }


        public static string URLEncode(string s)
        {
            s = s.Replace('+', '-').Replace('/', '_').Replace("=", ""); // no padding
            return s;
        }
        string getParam(string url, string param)
        {
            String res = "";

            String substr = param + "=";
            int index = url.IndexOf(substr, StringComparison.OrdinalIgnoreCase);

            // -1 if not found
            if (index >= 0)
            {
                int indexEnd = index + substr.Length;
                int stringLength = url.Length - indexEnd;
                res = url.Substring(indexEnd, stringLength);
                string[] arr = res.Split(char.Parse("&"));
                if (arr.Length > 0)
                {
                    res = arr[0];
                }
                return res;

            }
            return null;
        }
        
        
     

    }
    
   
}
